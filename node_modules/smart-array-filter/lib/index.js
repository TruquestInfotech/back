"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filter = void 0;
const lodash_escaperegexp_1 = __importDefault(require("lodash.escaperegexp"));
const match_1 = __importDefault(require("./match/match"));
const charSplit_1 = __importDefault(require("./utils/charSplit"));
const convertKeywordToCriterion_1 = require("./utils/convertKeywordToCriterion");
const ensureObjectOfRegExps_1 = __importDefault(require("./utils/ensureObjectOfRegExps"));
/**
 *
 * Filter.
 *
 * @param data - Array to filter.
 * @param [options={}] - Object.
 * @param [options.limit=Infinity] - Maximum number of results.
 * @param [options.caseSensitive=false] - By default we ignore case.
 * @param [options.ignorePaths=[]] - Array of jpath to ignore.
 * @param [options.includePaths] - Array of jpath to allow, default everything.
 * @param [options.pathAlias={}] - Key (string), value (string of regexp).
 * @param [options.keywords=[]] - List of keywords used to filter the array.
 * @param [options.index=false] - Returns the indices in the array that match.
 * @param [options.predicate='AND'] - Could be either AND or OR.
 * @returns String[] | number[].
 */
function filter(data, options = {}) {
    let { index = false, predicate = 'AND', ignorePaths: ignorePathsOption = [], includePaths: includePathsOption, pathAlias: pathAliasOption = {}, } = options;
    const limit = options.limit ? options.limit : Infinity;
    const insensitive = options.caseSensitive ? '' : 'i';
    let keywords = options.keywords || [];
    const pathAlias = (0, ensureObjectOfRegExps_1.default)(pathAliasOption, { insensitive });
    const ignorePaths = ignorePathsOption.map((path) => typeof path === 'string'
        ? new RegExp(`(^|\\.)${(0, lodash_escaperegexp_1.default)(path)}(\\.|$)`, insensitive)
        : path);
    const includePaths = includePathsOption
        ? includePathsOption.map((path) => typeof path === 'string'
            ? new RegExp(`(^|\\.)${(0, lodash_escaperegexp_1.default)(path)}(\\.|$)`, insensitive)
            : path)
        : undefined;
    if (typeof keywords === 'string') {
        keywords = (0, charSplit_1.default)(keywords, /[ \t\r\n]/);
    }
    const criteria = (0, convertKeywordToCriterion_1.convertKeywordsToCriteria)(keywords, {
        caseSensitive: options.caseSensitive,
        pathAlias,
    });
    let matched = 0;
    if (index) {
        const result = [];
        for (let i = 0; i < data.length && matched < limit; i++) {
            if ((0, match_1.default)(data[i], criteria, predicate, {
                ignorePaths,
                includePaths,
                pathAlias,
            })) {
                matched = result.push(i);
            }
        }
        return result;
    }
    else {
        const result = [];
        for (let i = 0; i < data.length && matched < limit; i++) {
            if ((0, match_1.default)(data[i], criteria, predicate, {
                ignorePaths,
                includePaths,
                pathAlias,
            })) {
                matched = result.push(data[i]);
            }
        }
        return result;
    }
}
exports.filter = filter;
//# sourceMappingURL=index.js.map