"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nativeMatch_1 = __importDefault(require("./nativeMatch"));
/**
 * RecursiveMatch.
 *
 * @param element - String | number | Record<string, string>.
 * @param criterion - Criterion.
 * @param keys - String[].
 * @param options - Object.
 * @param options.ignorePaths - RegExp[].
 * @returns Boolean.
 */
function recursiveMatch(element, criterion, keys, options) {
    if (typeof element === 'object') {
        if (Array.isArray(element)) {
            for (const elm of element) {
                if (recursiveMatch(elm, criterion, keys, options)) {
                    return true;
                }
            }
        }
        else {
            for (const i in element) {
                keys.push(i);
                const didMatch = recursiveMatch(element[i], criterion, keys, options);
                keys.pop();
                if (didMatch)
                    return true;
            }
        }
    }
    else if (criterion.type === 'exists') {
        // we check for the presence of a key (jpath)
        if (criterion.key.test(keys.join('.'))) {
            return !!element;
        }
        else {
            return false;
        }
    }
    else {
        // need to check if keys match
        const joinedKeys = keys.join('.');
        for (const ignorePath of options.ignorePaths) {
            if (ignorePath.test(joinedKeys))
                return false;
        }
        if (options.includePaths) {
            let included = false;
            for (const includePath of options.includePaths) {
                if (includePath.test(joinedKeys)) {
                    included = true;
                    break;
                }
            }
            if (!included)
                return false;
        }
        if (criterion.key) {
            if (!criterion.key.test(joinedKeys))
                return false;
        }
        return (0, nativeMatch_1.default)(element, criterion);
    }
    return false;
}
exports.default = recursiveMatch;
//# sourceMappingURL=recursiveMatch.js.map