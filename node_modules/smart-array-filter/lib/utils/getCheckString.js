"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitStringOperator = void 0;
const lodash_escaperegexp_1 = __importDefault(require("lodash.escaperegexp"));
const charSplit_1 = __importDefault(require("./charSplit"));
const operators = {
    '<': function lt(query) {
        return (string) => {
            return string < query[0];
        };
    },
    '<=': function lte(query) {
        return (string) => {
            return string <= query[0];
        };
    },
    '=': function equal(query, insensitive) {
        const possibilities = (0, charSplit_1.default)(query[0], ',')
            .filter((item) => item)
            .map((string) => new RegExp(`^${(0, lodash_escaperegexp_1.default)(string)}$`, insensitive));
        return (string) => {
            for (const possibility of possibilities) {
                if (possibility.test(string)) {
                    return true;
                }
            }
            return false;
        };
    },
    '~': function fuzzy(query, insensitive) {
        const possibilities = (0, charSplit_1.default)(query[0], ',')
            .filter((item) => item)
            .map((string) => new RegExp((0, lodash_escaperegexp_1.default)(string), insensitive));
        return (string) => {
            for (const possibility of possibilities) {
                if (possibility.test(string)) {
                    return true;
                }
            }
            return false;
        };
    },
    '>=': function lge(query) {
        return (string) => {
            return string >= query[0];
        };
    },
    '>': function lg(query) {
        return (string) => {
            return string > query[0];
        };
    },
    '..': function range(query) {
        return (string) => {
            return string >= query[0] && string <= query[1];
        };
    },
};
/**
 * GetCheckString.
 *
 * @param keyword - String.
 * @param insensitive - String.
 * @returns CheckString. (string)=>boolean.
 */
function getCheckString(keyword, insensitive) {
    const { values, operator } = splitStringOperator(keyword);
    const operatorCheck = operators[operator];
    if (!operatorCheck) {
        throw new Error(`unreachable unknown operator ${operator}`);
    }
    return operatorCheck(values, insensitive);
}
exports.default = getCheckString;
/**
 * @internal
 */
function splitStringOperator(keyword) {
    const parts = keyword.split('..');
    const match = /^\s*\(?(?<operator><=|<|=|>=|>)?\s*(?<value>\S*)\s*\)?$/.exec(parts[0]);
    if (!match) {
        // Should never happen
        return {
            operator: '~',
            values: [keyword],
        };
    }
    if (!match.groups) {
        throw new Error('unreachable');
    }
    let { operator, value } = match.groups;
    let secondQuery = parts[1]?.trim();
    let values = [value];
    if (parts.length > 1) {
        operator = '..';
        if (!secondQuery) {
            operator = '>=';
        }
        else if (!value) {
            values = [secondQuery];
            operator = '<=';
        }
        else {
            values.push(secondQuery);
        }
    }
    return {
        operator: operator || '~',
        values,
    };
}
exports.splitStringOperator = splitStringOperator;
//# sourceMappingURL=getCheckString.js.map